{"componentChunkName":"component---src-templates-blog-post-js","path":"/kubernetes-concepts-cheat-sheet","result":{"data":{"markdownRemark":{"html":"<p>Recently, I've been learning more about infamously difficult to learn Kubernetes for container orchestration (primarily for work, though I will openly admit that I've been curious about it for a while). The first thing that became immediately obvious was that there was a lot of terminology being thrown around. Pods, Replica Sets, Damonsets, Deployments, etc al - there's just a boatload of terminology that comes with learning kubernetes. However, if you are familiar with docker, docker-compose, and docker-swarm, you'll notice that there's a surprisingly large amount of 1-to-1 correlations between kubernetes terminology and docker concepts. As it turns out, kubernetes (at a high level) intuitively makes sense, it's just confusing initially because of all the terminology.</p>\n<p>So quick and dirty, here's a quick list of all the terminology I've learned so far:</p>\n<ul>\n<li>\n<p>Cluster - a bunch of servers that run your application servers, etc.</p>\n<ul>\n<li>the cluster is the available compute resources available, kubernetes will distribute containers across the cluster, and auto scale it, depending on how you've configured kube</li>\n</ul>\n</li>\n<li>\n<p>Node - a server in your cluster</p>\n<ul>\n<li>each node has a container runtime</li>\n</ul>\n</li>\n<li>\n<p>Pod - One or more containers that run together</p>\n<ul>\n<li>e.g. a pod of nginx, or a pod of a nginx container + node container</li>\n<li>note, these pods are ephemeral, and can be thought of as a single base unit of functionality</li>\n<li>each pod has a unique IP address, and containers in a pod can talk to each other via local networking (similar to how docker networking enables local containers to relay messages to each other)</li>\n</ul>\n</li>\n<li>\n<p>ReplicaSet - a set of identical pods</p>\n<ul>\n<li>ReplicaSets strive to maintain a stable set of pods</li>\n<li>the number of pods to maintain is usually determined via configuration</li>\n<li>You can think of a ReplicaSet similarly to an Abstract Class. Deployments, DaemonSets, Cronjob Set, etc, are pretty much ReplicaSets that do something more specific</li>\n<li>e.g. a DaemonSet strives to maintain X number of Pods on every node in a cluster.</li>\n</ul>\n</li>\n<li>\n<p>Deployment - manages ReplicaSets, runs continuously</p>\n<ul>\n<li>kube will appropriately distribute pods in a deployment across a cluster</li>\n<li>e.g. a Deployment of nginx could be a ReplicaSet of X number of application pods (such as a rails app, node, golang, etc al)</li>\n</ul>\n</li>\n<li>\n<p>DaemonSet - a ReplicaSet where each node a cluster must have a copy of the specified Pod</p>\n<ul>\n<li>e.g. running a logs collection daemon on each node in the cluster</li>\n</ul>\n</li>\n<li>\n<p>Jobs ReplicaSet - a set of pods spun up and down for short-lived jobs</p>\n<ul>\n<li>a CronJob ReplicaSet runs a Jobs ReplicaSet on some specified schedule</li>\n</ul>\n</li>\n<li>\n<p>Service - A way to expose a specific set of Pods</p>\n<ul>\n<li>the service is accessible via it's service name, similar to how you can referring to running docker containers in a docker-compose file via it's container or service name)</li>\n</ul>\n</li>\n<li>Cluster IP service - as the name suggests, enables addressing a service in the cluster via DNS (via Kubernetes DNS)</li>\n<li>\n<p>Node port service - exposes a port on every single node in the cluster, and maps that port to pods in a specified cluster IP service</p>\n<ul>\n<li>this is usually used for to expose pods to some external service that can't interface with kubernetes e.g. an external load balancer, etc</li>\n</ul>\n</li>\n<li>\n<p>Ingress and Ingress controller - An ingress is a declarative way to declare an interface between your kubernetes services and the internet/outside traffic</p>\n<ul>\n<li>an Ingress controller is the actually underlying reverse proxy that directs traffic for the ingress you've declared</li>\n<li>e.g. An Ingress controller can be an AWS ALB, or HAProxy, etc</li>\n</ul>\n</li>\n</ul>","timeToRead":3,"frontmatter":{"date":"July 03, 2019","path":"/kubernetes-concepts-cheat-sheet","title":"A Basic Cheat Sheet for Kubernetes terminology","tags":["docker","kubernetes"]}}},"pageContext":{"pathSlug":"/kubernetes-concepts-cheat-sheet","next":{"id":"29398004-0e7e-5b4c-97da-e2dfe0e1e1b3","frontmatter":{"path":"/setup-home-server","title":"Setting up a home server from scratch","tags":["nginx","nas","ddclient","namecheap","dns","certbot","letsencrypt","docker","docker-compose"],"date":"05/27/2020"}},"previous":{"id":"f83df265-3c9d-5753-931a-4a76abf55d72","frontmatter":{"path":"/compound-components-modal","title":"Building Flexible and Reusable React Compound Components","tags":["Compound Components","React","javascript","react context"],"date":"04/25/2019"}}}},"staticQueryHashes":["3000541721"]}